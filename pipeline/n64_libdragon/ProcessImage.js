const Util = require("../Util");

const fs = require("fs");
const path = require("path");
const util = require("util");
const DfsAssets = require("./DfsAssets");

const execFile = util.promisify(require('child_process').execFile);

const mkspritePath = "/opt/libdragon/bin/mksprite";


async function processImage(imageJson, dfsBundle, assetDirectory, outputDirectory) {
    const name = Util.safeDefineName(Object.hasOwn(imageJson, "name") ? imageJson.name : path.basename(imageJson.src, path.extname(imageJson.src)));
    const format = Object.hasOwn(imageJson, "format") ? imageJson.format.toUpperCase() : "RGBA16";
    const sourcePath = path.join(assetDirectory, imageJson.src);

    // write the ImageInfo file
    // this needs to match up with libdragon_image.h
    const hslices = Object.hasOwn(imageJson, "hslices") ? imageJson.hslices : 1;
    const vslices = Object.hasOwn(imageJson, "vslices") ? imageJson.vslices : 1;

    const imageInfoBuffer = Buffer.alloc(8);
    imageInfoBuffer.writeUInt32BE(hslices, 0);
    imageInfoBuffer.writeUInt32BE(vslices, 4);

    const imageInfoPath = path.join(outputDirectory, dfsBundle.nextId.toString())
    const imageInfoFile = fs.openSync(imageInfoPath, "w");
    fs.writeSync(imageInfoFile, imageInfoBuffer);
    fs.closeSync(imageInfoFile);

    const assetId = dfsBundle.addImage(imageInfoPath, name);

    const mkspriteArgs = [
        "--output", outputDirectory,
        "--compress", "0",
        "-f", format,
        sourcePath
    ];

    // console.log(">>>>>>>>>>>>>>>>>>>>>>>>>> mksprite");
    // console.log(mkspriteArgs.join(' '));
    // console.log(">>>>>>>>>>>>>>>>>>>>>>>>>> mksprite");
    
    await execFile(mkspritePath, mkspriteArgs);

    // This path is automatically generated by the mksprite program
    const convertedSpriteFile = path.join(outputDirectory, path.basename(sourcePath, path.extname(sourcePath)) + ".sprite");
    const convertedAssetIdFile = path.join(outputDirectory, dfsBundle.nextId.toString());

    if (!fs.existsSync(convertedSpriteFile)) {
        throw new Error(`Error converting sprite: ${sourcePath}`);
    }

    fs.renameSync(convertedSpriteFile, convertedAssetIdFile);

    dfsBundle.withoutDefiningAssets(()=> {
        dfsBundle.addImage(convertedAssetIdFile, name);
    });

    return assetId;
}

module.exports = processImage;